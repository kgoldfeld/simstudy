---
title: "Customized Distributions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Customized Distributions}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r chunkname, echo=-1}
data.table::setDTthreads(2)
```

```{r, echo = FALSE, message = FALSE}
library(simstudy)
library(ggplot2)
library(scales)
library(grid)
library(gridExtra)
library(survival)
library(gee)
library(data.table)
library(ordinal)

odds <- function (p)  p/(1 - p) # TODO temporary remove when added to package
plotcolors <- c("#B84226", "#1B8445", "#1C5974")

cbbPalette <- c("#B84226","#B88F26", "#A5B435", "#1B8446",
                "#B87326","#B8A526", "#6CA723", "#1C5974") 

ggtheme <- function(panelback = "white") {
  
  ggplot2::theme(
    panel.background = element_rect(fill = panelback),
    panel.grid = element_blank(),
    axis.ticks =  element_line(colour = "black"),
    panel.spacing =unit(0.25, "lines"),  # requires package grid
    panel.border = element_rect(fill = NA, colour="gray90"), 
    plot.title = element_text(size = 8,vjust=.5,hjust=0),
    axis.text = element_text(size=8),
    axis.title = element_text(size = 8)
  )  
  
}

```

Custom distributions can be specified in `defData` and `defDataAdd` by using the specifying "custom" for the argument *dist*. The name of the user-defined function is specified as a string in the *formula* argument. The arguments of the custom function are specified in the *variance* argument, as a comma delimited string. One important feature of the custom function is that the parameter list used to define the function must include "**n = n**", but this will not be included in the data definition.

### Example 1

Here is an example where we would like to generate data from a zero-inflated beta distribution. In this case, there is a user-defined function `zeroBeta` that takes on shape parameters $a$ and $b$, as well as $p_0$, the proportion of the sample that is zero:

```{r}
zeroBeta <- function(n, a, b, p0) {
  betas <- rbeta(n, a, b)
  is.zero <- rbinom(n, 1, p0)
  betas*!(is.zero)
}
```

The data definition specifies a new variable $zb$ that will sets $a$ and $b$ to 0.75, and $p_0 = 0.02$:

```{r}
def <- defData(
  varname = "zb", 
  formula = "zeroBeta", 
  variance = "a = 0.75, b = 0.75, p0 = 0.02", 
  dist = "custom"
)
```

The data are generated:

```{r}
set.seed(1234)
dd <- genData(100000, def)
```

```{r, echo = FALSE}
dd
```

A plot of the data reveals dis-proportion of zero's:

```{r, fig.width = 6, fig.height = 3, echo = FALSE}
ggplot(data = dd, aes(x = zb)) +
  geom_histogram(binwidth = 0.01, boundary = 0, fill = "grey60") +
  theme(panel.grid = element_blank()) 
```

### Example 2

In this case, we are generating a mixture of truncated distributions, where the limits of the truncation vary across three different groups. `rnormt` is a customized (user-defined) function that generates truncated data from a Gaussian distribution. The function requires up to four arguments (the left truncation value, the right truncation value, the distribution average and the standard deviation).

```{r}
rnormt <- function(n, min, max, mu = 0, s = 1.5) {
  
  F.a <- pnorm(min, mean = mu, sd = s)
  F.b <- pnorm(max, mean = mu, sd = s)
  
  u <- runif(n, min = F.a, max = F.b)
  qnorm(u, mean = mu, sd = s)
  
}
```

In this example, the truncation limits vary by group membership. There are three groups.  We only pass three parameters (the limits and the mean), using the default standard deviation.

```{r}
def <-
  defData(
    varname = "limit", 
    formula = "1/4;1/2;1/4",
    dist = "categorical"
  ) |>
  defData(
    varname = "tn", 
    formula = "rnormt", 
    variance = "min = -limit, max = limit, mu = 0.5",
    dist = "custom"
  )

dd <- genData(100000, def)
```

```{r, echo=FALSE}
dd
```

A plot highlights the group differences.

```{r, fig.width = 8, fig.height = 3, echo = FALSE}
ggplot(data = dd, aes(x = tn)) +
  geom_histogram(aes(fill = factor(limit)), binwidth = 0.05, boundary = 0, alpha = .8) +
  facet_grid( ~ limit) +
  theme(panel.grid = element_blank(),
        legend.position = "none") +
  scale_fill_manual(values = plotcolors) +
  scale_x_continuous(breaks = seq(-3, 3, by =1))
```

